<template>
  <div class="par-box">
    <div class="demo-top">
      <!-- <i class="el-icon-arrow-left goback" @click="goBack"></i> -->
      <img src="../../../assets/images/index/building-icon.png" alt="" />
      <h6>博智林总部大楼 > {{ organizationName }}栋</h6>
    </div>
    <!-- <el-scrollbar style="height:100%" class="par-scroll"> -->
    <div class="robot-container">
      <dl class="floor-in-build">
        <dt>楼层</dt>
        <div class="floor-box">
          <dd v-for="(item, idx) in floorList" :key="idx" @click="changeFloorIdx(idx, item.mapId)" :class="floorChoose == idx ? 'floor-active' : ''">
            <span :class="[floorChoose == idx ? 'floor-item-active ' : '']" style="">{{ item.floor }}</span>
            <i class="el-icon-caret-right" v-show="floorChoose == idx"></i>
          </dd>
        </div>
      </dl>

      <!-- 画布 -->
      <div class="map-cantain" id="map">
        <!-- <canvas id="canvas" :width="canvasW" :height="canvasH"></canvas> -->
        <!--  -->
        <!-- 电梯 -->
        <div class="lift-box" v-show="animate">
          <div class="lift">
            <div class="lift-head">
              <p v-show="active == 'up'" :class="['up', animate ? 'move-up' : '']"></p>
              <p v-show="active == 'down'" :class="['down', animate ? 'move-down' : '']"></p>
              <p>{{ floor }}&nbsp;F</p>
            </div>
            <!-- <div class="lift-foot">
                <p></p>
                <div>
                  <img src="../../../assets/images/index/robot.png" alt="">
                </div>
              </div> -->
          </div>
          <!-- <img :src="liftImg" alt=""> -->
          <img src="../../../assets/images/map/lift1.gif" alt="" />
        </div>
        <!-- 图标说明 -->

        <div class="map-icon-desc" v-show="showIcon">
          <dl>
            <dt><h6>图标说明</h6></dt>
            <dd>
              <img src="../../../assets/images/index/station1.png" alt="" />
              工作站
            </dd>
            <dd>
              <img src="../../../assets/images/index/station4.png" alt="" />
              工作站前方
            </dd>
            <dd>
              <img src="../../../assets/images/index/station2.png" alt="" />
              工作站补给点
            </dd>
            <dd class="station">
              <img src="../../../assets/images/index/station3.png" alt="" />
              工作站待机点
            </dd>
            <dd>
              <img src="../../../assets/images/index/elevator3.png" alt="" />
              呼梯待机点
            </dd>
            <dd>
              <img src="../../../assets/images/index/elevator1.png" alt="" />
              乘梯点
            </dd>
            <dd class="elevation">
              <img src="../../../assets/images/index/elevator2.png" alt="" />
              出梯点
            </dd>
            <dd>
              <img src="../../../assets/images/index/map-out.png" alt="" />
              地图入口
            </dd>
            <dd class="map-out">
              <img src="../../../assets/images/index/map-in.png" alt="" />
              地图出口
            </dd>
          </dl>
        </div>

        <!-- 左上角工具箱 -->
        <div class="magnifier-box" v-show="mapOrigin.width && mapOrigin.height">
          <img src="../../../assets/images/map/bigicon.png" class="scale-icon" @click.stop="scale(1,'button')" />
          <img src="../../../assets/images/map/smallicon.png" class="scale-icon" @click.stop="scale(-1,'button')" />
          <span class="tool-icon">
            <span @click="changeShowToolBox" class="span-tool">
              <img src="../../../assets/images/index/tool-icon.png" />
              <span>工具箱</span>
              <i class="el-icon-arrow-down" v-if="showToolBox"></i>
              <i class="el-icon-arrow-up" v-else></i>
            </span>
            <ul class="choose-drop" v-show="showToolBox">
              <li
                v-for="(item, idx) in toolDesc"
                :key="idx"
                :class="toolObj.toolChooseAll == idx || toolObj.toolChooseFocus == idx || toolObj.toolChooseIcon == idx ? 'active' : ''"
                @click="changeTool(idx)"
              >
                <i class="el-icon-check" v-show="toolObj.toolChooseAll == idx || toolObj.toolChooseFocus == idx || toolObj.toolChooseIcon == idx"></i>
                {{ item }}
              </li>
            </ul>
          </span>
        </div>

        <!-- 机器人说明信息 -->
        <div
          class="robot-message"
          v-show="canvasActiveRobot.showMessage"
          :style="{ top: canvasActiveRobot.top, left: canvasActiveRobot.left, borderColor: canvasActiveRobot.color[canvasActiveRobot.alarmLevel] }"
        >
          <div class="img-icon" :style="{ background: canvasActiveRobot.alarmLevel == 1 ? '#FFD052' : canvasActiveRobot.alarmLevel == 2 ? '#F4635D' : '#D8D8D8' }">
            <img src="../../../assets/images/index/small-robot.png" alt="" />
          </div>
          <h6>
            <p>{{ canvasActiveRobot.name }}</p>
            <p>{{ canvasActiveRobot.id }}</p>
          </h6>
        </div>
      </div>

      <!-- 机器人集合 -->
      <div class="robot-group">
        <ul class="robot-roup-ul">
          <li
            v-for="(item, idx) in robotIdArr"
            :key="idx"
            :class="['robot-roup-li', item.isMqttState ? '' : 'robot-model', activeRobot == item.robotId ? 'li-active-robot' : '']"
            @click="changeRobot(item.mapId, item.connectionStatus, item.robotId)"
          >
            <div class="left">
              <div class="left-img" :style="{ 'border-color': item.connectionStatus ? item.color : '#ccc' }">
                <img src="../../../assets/images/index/robot-back.png" alt="" />
                <i class="el-icon-warning" v-show="item.alarmLevel && item.alarmLevel != 0" :style="{ color: item.alarmLevel == 1 ? '#FFD052' : '#F4635D' }"></i>
              </div>

              <span class="robot-status-text">{{ item.connectionStatus ? '在线' : '离线' }}</span>
              <!-- <span class="robot-status-text">{{robotStatusArrTag[item.robotStatus]}}</span> -->
            </div>
            <div class="right">
              <p class="robot-name">
                <span>{{ item.robotName }}</span>
                <img :src="activeRobot == item.robotId ? starFocus : starIcon" alt="" @click.stop="setStar(idx, item.mapId, item.robotId, item.connectionStatus)" />
              </p>
              <p class="robot-id">{{ item.robotId }}</p>

              <p class="work-progress"><el-progress :percentage="item.connectionStatus ? item.taskProcess : 0" :color="item.color"></el-progress></p>
              <ul class="robot-status">
                <li>
                  <el-progress :show-text="false" :percentage="item.connectionStatus ? item.batteryRemain : 0" class="battery-gress"></el-progress>
                  <i></i>
                  <span class="battery-text">{{ item.connectionStatus && item.batteryRemain ? item.batteryRemain + '%' : '-' }}</span>
                </li>
                <li>
                  <el-tooltip class="item" effect="dark" content="清水箱" placement="top"><img src="@/assets/images/work/clean-water.png" alt="" /></el-tooltip>

                  <span>{{ item.connectionStatus && item.cleanWater ? item.cleanWater : '-' }}</span>
                </li>
                <li>
                  <el-tooltip class="item" effect="dark" content="污水箱" placement="top"><img src="@/assets/images/work/dirty-water.png" alt="" /></el-tooltip>

                  <span>{{ item.connectionStatus && item.dirtyWater ? item.dirtyWater : '-' }}</span>
                </li>
              </ul>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>

<script>
import Worker from 'worker-loader!../../../worker/worker'
import LineWorker from 'worker-loader!../../../worker/lineWorker'
// import { fabric } from 'fabric'
import { bottomImg, mapAndRobot, getMessage, getfloorMap } from '@/api/clean-robot/map.js'
import { toEulerAngle, getDegree } from '../../../util/point.js'
import { throttle } from 'lodash'
const robotIcon = require('@/assets/images/index/robot-direction-icon.png')
const robotStar = require('@/assets/images/index/starRobot.png')
export default {
  name: '',
  data() {
    return {
      floorChoose: '',
      toolObj: {
        toolChooseAll: 0, //默认选中所有机器人路径
        toolChooseFocus: -1, //选中焦点机器人
        toolChooseIcon: -1 //默认隐藏图标说明
      },
      showIcon: false, //图标说明
      showToolBox: false,
      organizationName: 'A',
      floorList: [],

      robotIds: [], // 当前楼层上的机器人
      robotIdArr: [], //楼栋中所有的机器人
      // robotIdArr: [{ robotId: 'AAAAAAAAAAAAAAAA', robotName: 'R001', taskProcess: 90, batteryRemain: 100, cleanWater: '正常', dirtyWater: '正常', robotStatus: 1 }], //楼栋中所有的机器人
      starFocus: require('../../../assets/images/index/star1.png'),
      starIcon: require('../../../assets/images/index/star2.png'),
      // robotStatusArrTag: ['待机', '自动清扫', '手动清扫', '补给中', '乘梯中', '建图中', '故障', '离线'],
      toolDesc: ['显示路径', '只显示焦点机器人', '隐藏图标说明'],
      floor: '', // 电梯楼层
      active: '', // 显示动画
      animate: false, //是否显示电梯提示（机器人切换楼层上下行的时候才显示）
      // mapId: '',
      mapId: '',
      // robotId: '00000000000000000012',
      canvasH: '700px',
      canvasW: '1364.64px',
      resolutionX: 0.02,
      resolutionY: 0.02,
      mapOrigin: {
        width: '',
        height: ''
      },
      pressOrigin: {
        x: '',
        y: ''
      },
      scalePercent: {
        left: 0,
        top: 0,
        x: '', // 原始的width的比例
        y: '', // 原始的height的比例
        now: 0,
        before: ''
      },
      bottomMap: '',
      elevatorStatusMqtt: '',
      robotStatusMqtt: '',
      drawArea: '', // canvas画布对象
      mqtt: '',
      drawShape: {
        robot: {}, // 绘制的机器人列表
        line: {} // 绘制的路径列表
      },
      robotImg: '',
      starImg: '',
      robotColor: {
        useColor: [],
        notUseColor: ['#a610c0', '#ff7ed6', '#ff9216', '#af5000', '#3bba00', '#00c2e0', '#4157ff', '#F0E68C', '#B0C4DE']
        // notUseColor: ['#5F9EA0', '#FF9016','#F0E68C', '#E9967A', '#F08080', '#8A2BE2','#4169E1','#B0C4DE','#98FB98']
      },
      activeRobot: '',
      showLine: true,
      showActiveRobot: false,
      base64: '',
      historyLine: {}, // 历史路径
      canvasActiveRobot: {
        press: false,
        activeLength: 0,
        showMessage: false,
        id: '',
        name: '',
        top: 0,
        left: 0,
        alarmLevel: 0,
        color: {
          '-1': '#D8D8D8',
          0: 'transparent',
          1: '#FFD052',
          2: '#F4635D'
        }
      },
      stopRender: {
        move: false,
        scale: false,
        all: false
      },
      finger: {
        x: '',
        y: ''
      },
      outlineMapRobot: {}, // 暂时保存离线机器人
      worker: '',
      historyWorker: '',
      spacePath: '',
      spaceHistoryPath: '',
      hasTen: '', // 是否存在10楼
      fresh: '',
      mapRobotTime: '',
      historyArr: '', // 一次性的history数组
      saveMap: {},
      pressing: false,
      firstIn: true, // 保存是否第一次进入
      mousePosi: {
        x: '',
        y: ''
      },
      lift: {
        0: '',
        1: '',
        2: '',
        4: ''
      },
      liftImg: ''
    }
  },
  created() {
    this.getLiftImg()
    this.getIconImg()
  },
  async mounted() {
    await this.getFloor()
    await this.getrobotList()
    const alreadyImg = () => {
      Promise.all(this.historyArr)
        .then(res => {
          console.log('获取完数据')
          this.handleHistory()
        })
        .catch(e => {
          this.$message({
            message: '获取历史路径错误',
            type: 'error'
          })
          this.handleHistory()
        })
    }
    await this.getBottomImg(alreadyImg)
    this.mqttStart()
    if (localStorage.getItem('toolObj')) {
      const loginUserId = JSON.parse(localStorage.getItem('robot_userInfo')).id
      if (JSON.parse(localStorage.getItem('toolObj')).UserId == loginUserId) {
        this.toolObj = JSON.parse(localStorage.getItem('toolObj'))
        this.activeRobot = this.toolObj.activeRobot
      }
      const activeRobot = JSON.parse(localStorage.getItem('toolObj')).activeRobot
      this.robotIdArr.forEach(e => {
        //当上次设定的焦点机器人在线，本次焦点机器人还是ta，并且记录上一次工具箱选择
        // console.log(e)
        if (!activeRobot) {
          this.toolObj.toolChooseFocus = -1
        }
        if (e.robotId == activeRobot && !e.connectionStatus) {
          console.log(e.connectionStatus)
          this.toolObj.activeRobot = '' //记录的焦点
          this.activeRobot = ''
          this.toolObj.toolChooseFocus = -1
        }
      })
      this.showLine = this.toolObj.toolChooseAll != -1
      this.showActiveRobot = this.toolObj.toolChooseFocus != -1
    }
  },
  beforeDestroy() {
    clearInterval(this.fresh)
    clearInterval(this.mapRobotTime)
    this.fresh = null
    this.mapRobotTime = null
    if (this.mqtt) {
      this.mqtt.subArr.forEach(item => {
        this.mqtt.unsub(item)
      })
      this.mqtt.disconnect()
    }
  },
  methods: {
    compatibleMobile() {
      this.drawArea.on({
        'touch:drag': event => {
          const { e, self } = event
          // console.log(e, self)
          switch (e.type) {
            case 'touchstart':
              if (e.touches.length == 1) {
                this.mouseDown(self, e.touches[0])
              }
              // console.log('start', self)
              break
            case 'touchmove':
              this.mouseMove(self, e.touches[0])
              // console.log('move', self)
              break
            case undefined:
              this.mouseUp(self)
              // console.log('end', e)
              break
          }
        }
      })
    },
    workScaleMove() {
      const data = {}
      data.scalePercent = this.scalePercent
      data.activeRobot = this.activeRobot
      data.showLine = this.showLine
      data.drawLine = this.drawShape.line
      data.showActiveRobot = this.showActiveRobot
      this.worker.postMessage(JSON.stringify(data))
    },
    getWorkerMes({ data }) {
      // 多线程worker
      const drawLine = JSON.parse(data)
      // console.log(draw)
      for (const key in this.drawShape.line) {
        if (drawLine[key]) {
          this.drawArea.remove(this.drawShape.line[key].el)
          const color = drawLine[key].color
          const opacity = drawLine[key].opacity
          this.resetSpacePath(drawLine[key].path, color, opacity)
          this.drawShape.line[key].el = this.spacePath
          this.drawArea.add(this.spacePath)
          this.drawArea.moveTo(this.spacePath, 1)
        }
      }
    },
    resetSpacePath(path, color, opacity) {
      this.spacePath = new fabric.Path(path, {
        stroke: color,
        fill: 'transparent',
        strokeWidth: 2,
        lockScalingX: true,
        lockScalingY: true,
        lockMovementY: true,
        lockMovementX: true,
        lockRotation: true,
        hoverCursor: 'default',
        evented: false,
        selectable: false,
        opacity
      })
      // console.log(this.spacePath)
    },
    getLineWorker({ data }) {
      const historyLine = JSON.parse(data)
      for (const key in historyLine) {
        for (const l in historyLine[key]) {
          const { color, opacity, path } = historyLine[key][l]
          this.resetHistoryPath(path, color, opacity)
          this.historyLine[key][l + 'el'] && this.drawArea.remove(this.historyLine[key][l + 'el'])
          this.historyLine[key][l + 'el'] = this.spaceHistoryPath
          this.drawArea.add(this.spaceHistoryPath)
          this.drawArea.moveTo(this.spaceHistoryPath, 0)
        }
      }
      this.historyWorker.terminate()
    },
    resetHistoryPath(path, color, opacity) {
      this.spaceHistoryPath = new fabric.Path(path, {
        stroke: color,
        fill: 'transparent',
        strokeWidth: 2,
        lockScalingX: true,
        lockScalingY: true,
        lockMovementY: true,
        lockMovementX: true,
        lockRotation: true,
        hoverCursor: 'default',
        evented: false,
        selectable: false,
        opacity
      })
    },
    getIconImg() {
      const robot = new Image()
      robot.src = robotIcon
      robot.onload = () => {
        this.robotImg = robot
      }
      const star = new Image()
      star.src = robotStar
      star.onload = () => {
        this.starImg = star
      }
    },

    changeMapAndData(mapId) {
      this.scalePercent = {
        // 清空比例尺
        left: 0,
        top: 0,
        x: '', // 原始的width的比例
        y: '', // 原始的height的比例
        now: 0,
        before: ''
      }
      // 仅清除机当前机器人位置订阅
      this.mqtt &&
        this.mqtt.subArr &&
        this.mqtt.subArr.forEach(item => {
          if (item.indexOf('position') > -1) {
            this.mqtt.unsub({ topic: item })
          }
        })
      this.drawArea.clear && this.drawArea.clear() // 清除画布
      this.stopRender.all = true
      // 清除数据
      this.drawShape = {
        robot: {},
        line: {}
      }
      this.historyLine = {}
      this.mqtt.messageArr = []
      // 清空颜色
      // this.resetColor()
      //楼层上的机器人
      const arr = []
      const promiseArr = []
      this.robotIdArr.forEach(e => {
        //筛选选中楼层地图上的机器人
        if (e.mapId === mapId) {
          console.log('当前订阅的机器人', e.robotId)
          arr.push(e.robotId)
          if (e.connectionStatus) {
            //在线机器人
            promiseArr.push(
              (async e => {
                await this.getHistoryLine(e)
              })(e)
            )
          }
          this.subRobotPosi(true, e.robotId)
        }
      })
      this.robotIds = arr
      const alreadyImg = () => {
        this.stopRender.all = false
        Promise.all(promiseArr)
          .then(res => {
            console.log('获取完数据')
            this.handleHistory()
          })
          .catch(e => {
            this.$message({
              message: '获取历史路径错误',
              type: 'error'
            })
            this.handleHistory()
          })
      }
      this.getBottomImg(alreadyImg)
      // this.handleHistory()
    },
    //切换楼层
    async changeFloorIdx(idx, mapId) {
      if (this.floorChoose === idx) {
        //点击当前楼层不处理
        return
      }
      if (!mapId) {
        this.$message.error('没有获取到楼层地图,请稍后再试')
        return
      }
      this.activeRobot = '' //清空焦点机器人
      this.toolObj.toolChooseFocus = -1
      this.floorChoose = idx
      this.mapId = mapId
      this.changeMapAndData(mapId)
    },
    // 切换工具箱选项（选项不互斥）
    changeTool(idx) {
      if (idx === 0) {
        this.toolObj.toolChooseAll = this.toolObj.toolChooseAll == idx ? -1 : 0
        this.showLine = this.toolObj.toolChooseAll != -1
      }
      if (idx === 1) {
        if (!this.activeRobot) {
          this.$message.error('请先选择焦点机器人')
          return
        }
        this.toolObj.toolChooseFocus = this.toolObj.toolChooseFocus == idx ? -1 : 1
        this.showActiveRobot = this.toolObj.toolChooseFocus != -1
      }
      if (idx === 2) {
        this.showIcon = this.toolObj.toolChooseIcon == idx
        this.toolObj.toolChooseIcon = this.toolObj.toolChooseIcon == idx ? -1 : 2
      }

      this.showToolBox = false

      this.toolObj.UserId = JSON.parse(localStorage.getItem('robot_userInfo')).id
      localStorage.setItem('toolObj', JSON.stringify(this.toolObj))

      // 1. ① √   ②×     显示地图上所有机器人图标以及其路径
      // 2. ① √   ②√     只显示焦点机器人图标以及其路径
      // 3. ① ×   ②√     只显示焦点机器人图标，地图上没有任何路径
      // 4. ① ×   ②×     只显示地图上所有机器人的图标，地图上没有任何路径
      for (const key in this.drawShape.line) {
        this.drawShape.line[key].el &&
          this.drawShape.line[key].el.set('opacity', this.showLine ? (this.activeRobot && this.showActiveRobot && this.activeRobot !== key ? 0 : 1) : 0)
      }
      for (const r in this.drawShape.robot) {
        this.drawShape.robot[r].el && this.drawShape.robot[r].el.set('opacity', this.activeRobot && this.activeRobot !== r && this.showActiveRobot ? 0 : 1)
        this.drawShape.robot[r].circle && this.drawShape.robot[r].circle.set('opacity', this.activeRobot && this.activeRobot !== r && this.showActiveRobot ? 0 : 0.45)
      }
      this.historyChange()
      this.drawArea.renderAll()
    },

    getLiftImg() {
      for (const key in this.lift) {
        this.lift[key] = require(`@/assets/images/map/lift${key}.gif`)
      }
    },

    // 点击工具箱显示选项
    changeShowToolBox() {
      if (this.showToolBox) {
        this.showToolBox = false
      } else {
        this.showToolBox = true
      }
    },
    getColor() {
      const color = this.robotColor.notUseColor[0]
      this.robotColor.useColor.push(color)
      this.robotColor.notUseColor.splice(0, 1)
      return color
    },
    resetColor() {
      this.robotColor.useColor = []
      this.robotColor.notUseColor = ['#FF9016', '#4169E1', '#5F9EA0', '#98FB98', '#F0E68C', '#E9967A', '#F08080', '#8A2BE2', '#B0C4DE']
    },
    //切换机器人

    async setStar(idx, mapId, robotId, status) {
      // 选中对应机器人，然后查询机器人所在楼层，然后查询机器人所在楼层的所有机器人id
      if (!status) {
        this.$message.error('离线机器人不能设置为焦点机器人')
        return
      }
      if (this.activeRobot == robotId) {
        // 选中自己
        this.activeRobot = ''
        this.toolObj.toolChooseFocus = -1
        this.showLine = this.toolObj.toolChooseAll != -1
        this.toolObj.activeRobot = ''
        localStorage.setItem('toolObj', JSON.stringify(this.toolObj))
        this.mqttElevator(false)
        return
      } else {
        this.activeRobot = robotId
        this.toolObj.activeRobot = this.activeRobot
        localStorage.setItem('toolObj', JSON.stringify(this.toolObj))
        this.mqttElevator(true)
      }

      if (this.mapId == mapId) {
        //如果点击的焦点机器人在当前楼层中
        this.historyChange()
        for (const key in this.drawShape.line) {
          // this.showLine ? (this.showActiveRobot && this.activeRobot !== key ? 0 : 1) : 0
          this.drawShape.line[key].el.set('opacity', this.showLine ? (this.showActiveRobot && this.activeRobot !== key ? 0 : 1) : 0)
        }
        for (const r in this.drawShape.robot) {
          this.drawShape.robot[r].el.set('opacity', this.activeRobot !== r && this.showActiveRobot ? 0 : 1)
          this.drawShape.robot[r].circle.set('opacity', this.activeRobot !== r && this.showActiveRobot ? 0 : 0.45)
        }
        this.drawArea.renderAll()
        return
      }
      this.mapId = mapId
      this.floorList.forEach((item, index) => {
        if (item.mapId == this.mapId) {
          this.floorChoose = index
        }
      })
      this.changeMapAndData(mapId)
    },
    async changeRobot(mapId, status, robotId) {
      if (!status) {
        this.$message.error('不能切换至离线机器人')
        return
      }
      if (this.canvasActiveRobot.showMessage) {
        return
      }
      if (this.mapId == mapId) {
        // 点击当前的楼层
        for (const key in this.drawShape.robot) {
          if (key == robotId) {
            this.canvasActiveRobot.id = key
            this.canvasActiveRobot.name = this.drawShape.robot[key].name
            this.canvasActiveRobot.top = this.drawShape.robot[key].el.top - 50 + 'px'
            this.canvasActiveRobot.left = this.drawShape.robot[key].el.left + 'px'
          }
        }
        this.robotIdArr.forEach(e => {
          if (this.canvasActiveRobot.id == e.robotId) {
            this.canvasActiveRobot.alarmLevel = e.alarmLevel
          }
        })
        if (this.canvasActiveRobot.top && this.canvasActiveRobot.left && this.canvasActiveRobot.name && this.canvasActiveRobot.id) {
          this.canvasActiveRobot.showMessage = true
          setTimeout(() => {
            this.canvasActiveRobot.showMessage = false
            this.canvasActiveRobot.activeLength = 0
            this.canvasActiveRobot.press = false
          }, 1500)
        } else {
          this.$message({
            message: '暂未获取到机器人详细信息,请稍后再点击'
          })
        }
        return
      }
      if (this.activeRobot) {
        // 点击其他机器人后切换地图需清除焦点机器人
        this.activeRobot = ''
      }
      this.floorChoose = this.floorList.findIndex(item => {
        return item.mapId === mapId
      })
      this.mapId = mapId
      this.changeMapAndData(mapId)
    },
    async mqttStart() {
      const certificateData = await this.$https('certificate')
      // 获取mqtt凭证
      const hostAport = (certificateData.brokerURL && certificateData.brokerURL.split(':')) || []
      const host = (hostAport && hostAport[0]) || null
      const port = (hostAport && hostAport[1]) || null
      this.mqtt = this.$link({
        host: host || process.env.VUE_APP_MQTT_HOST,
        port: port || process.env.VUE_APP_MQTT_PORT,
        userName: 'robot',
        password: 'bdr@147emqx!2020..',
        linkStart: this.linkStart,
        getMessage: this.handleMessage,
        dataLimit: true,
        clientId: certificateData.clientId
      })
      this.worker = new Worker()
      this.worker.onmessage = this.getWorkerMes
      this.mqtt.connect()
    },
    linkStart() {
      console.log('执行连接开始的函数')
      this.mqtt.sub({ topic: '/cloud/web/device/+/status/push' })
      this.robotIds.forEach(item => {
        this.subRobotPosi(true, item)
      })

      // this.test()
      // this.mqtt.sub({ topic: '/cloud/web/device/+/position/push' })
      // 轮询找到在线的机器人是否离线
      this.mapRobotTime = setInterval(() => {
        mapAndRobot(JSON.stringify({ organizationId: '16044558013591350' })).then(res => {
          res.data.robotIdMapIds &&
            res.data.robotIdMapIds.length &&
            res.data.robotIdMapIds.forEach(item => {
              this.robotIdArr.forEach(i => {
                // 之前的状态
                if (item.robotId == i.robotId) {
                  // 找到自己
                  if (item.connectionStatus !== i.connectionStatus && i.connectionStatus) {
                    i.connectionStatus = 0
                    this.outlineMapRobot[item.robotId] = ''
                    this.activeRobot = this.activeRobot && item.robotId == this.activeRobot ? '' : this.activeRobot // 焦点机器人离线清空
                    this.toolObj.toolChooseFocus = this.activeRobot && item.robotId == this.activeRobot ? -1 : this.toolObj.toolChooseFocus
                  }
                }
              })
            })
          for (const o in this.outlineMapRobot) {
            if (this.drawShape.line[o]) {
              this.drawArea.remove(this.drawShape.line[o].el)
              delete this.drawShape.line[o]
            }
            if (this.historyLine[o]) {
              for (const l in this.historyLine[o]) {
                if (this.historyLine[o][l].length && this.historyLine[o][l].length > 1) {
                  this.drawArea.remove(this.historyLine[o][l + 'el'])
                }
              }
              delete this.historyLine[o]
            }
            if (this.drawShape.robot[o]) {
              // this.drawArea.remove(this.drawShape.robot[o].el)
              this.drawArea.remove(this.drawShape.robot[o].circle)
              this.drawShape.robot[o].el.set('opacity', 0.2)
              this.outlineMapRobot[o] = this.drawShape.robot[o].el
              delete this.drawShape.robot[o]
            }
          }
          this.drawArea.renderAll()
        })
      }, 10000)
    },
    handleMessage(message) {
      const name = message.destinationName
      if (typeof name == 'string') {
        const isPosi = name.indexOf('position') > -1
        const isStatus = name.indexOf('status') > -1 && name.indexOf('device') > -1
        const isLift = name.indexOf('state') > -1
        // console.log(message.payloadString)
        const data = JSON.parse(message.payloadString)
        // console.log(data)
        if (isPosi) {
          // console.log('位置消息')
          this.handlerRobotMessage(data)
        }
        if (isLift) {
          // console.log('电梯消息')
          this.handleLift(data)
        }

        if (isStatus) {
          console.log('状态消息')
          // console.log(data)
          this.handleDeviceStatus(data)
        }
      }
    },
    subRobotPosi(state, id = '+') {
      // 对接机器人位置mqtt
      if (state) {
        this.mqtt.sub({
          topic: '/cloud/web/device/' + id + '/position/push'
        })
      } else {
        this.mqtt.unsub({
          topic: '/cloud/web/device/' + id + '/position/push'
        })
      }
    },
    mqttElevator(type, id = '+') {
      type ? this.mqtt.sub({ topic: '/cloud/web/elevator/' + id + '/state/push' }) : this.mqtt.unsub({ topic: '/cloud/web/elevator/' + id + '/state/push' })
    },
    test() {
      const obj = {
        // 模拟位置数据用
        data: {
          mapId: '333a22c1-a6b6-4e0a-86a6-18e97fa6cd30',
          orientationW: 0.9320093772594417,
          orientationX: 0.0,
          orientationY: 0.0,
          orientationZ: -0.36243416050431515,
          packTimestamp: 0,
          positionX: 105.22200511643638,
          positionY: 171.738617235422,
          positionZ: 0.0
        },
        deviceId: '00000000000000000016',
        sequence: 2020122308071146,
        timestamp: 1608692446433
      }
      const time = setInterval(() => {
        const newObj = {
          data: {
            mapId: '333a22c1-a6b6-4e0a-86a6-18e97fa6cd30',
            orientationW: 0.9320093772594417,
            orientationX: 0.0,
            orientationY: 0.0,
            orientationZ: -0.36243416050431515,
            packTimestamp: 0,
            positionX: obj.data.positionX - 1,
            positionY: obj.data.positionY - 1,
            positionZ: 0.0
          },
          deviceId: '00000000000000000016'
        }
        obj.data.positionX -= 1
        obj.data.positionY -= 1
        this.handlerRobotMessage(newObj)
      }, 2000)
      setTimeout(() => {
        clearInterval(time)
      }, 30000)
    },
    handleRotate(vector, deg, origin = { x: 0, y: 0 }) {
      const { x, y } = vector
      const cosA = Math.cos(deg)
      const sinA = Math.sin(deg)
      const x1 = (vector.x - origin.x) * cosA - (vector.y - origin.y) * sinA
      const y1 = (vector.x - origin.x) * sinA + (vector.y - origin.y) * cosA
      return {
        x: origin.x + x1,
        y: origin.y + y1
      }
    },
    async handlerRobotMessage(data) {
      if (this.stopRender.all) {
        // 清空画布后,绘制完毕后才能接收位置推送
        return
      }

      const value = data.data
      const robotMes = []
      const robotArr = this.robotIdArr.forEach(item => {
        if (item.connectionStatus) {
          //
          robotMes.push('机器人编号' + item.robotId + '对应map' + item.mapId)
        }
      })
      // console.log('推送机器人位置', 'mapId:', value.mapId, '在线机器人列表', robotMes, '未转换位置', { x: value.positionX, y: value.positionY })

      if (this.outlineMapRobot[data.deviceId]) {
        //离线变成在线
        this.drawArea.remove(this.outlineMapRobot[data.deviceId])
        delete this.outlineMapRobot[data.deviceId]
      }
      // 处理比例尺

      value.positionX = Number((value.positionX / this.resolutionX).toFixed(2))
      value.positionY = Number((this.mapOrigin.height - value.positionY / this.resolutionY).toFixed(2))
      // console.log('转换后位置', value.positionX, value.positionY)

      // if (this.drawShape.robot[data.deviceId] &&
      // ((this.drawShape.robot[data.deviceId].beforeX - value.positionX > 30) || (this.drawShape.robot[data.deviceId].beforeY - value.positionY > 30))) {
      //   return
      // } // 暂时取消过滤位置信息
      // const handleXY = this.handleRotate({ x: value.positionX, y: value.positionY })
      // value.positionX = handleXY.x
      // value.positionX = handleXY.y
      // console.log(handleXY)

      if (value.mapId == 'panpuwan') {
        // 只有泮浦湾的点特殊处理
        // x0= (x - rx0)*cos(a) - (y - ry0)*sin(a) + rx0 ; 以某点进行旋转的公式 (rx0,ry0)是（2440，1634）
        // y0= (x - rx0)*sin(a) + (y - ry0)*cos(a) + ry0 ;
        value.positionX = (value.positionX - 2440) * Math.cos(Math.PI) - (value.positionY - 1634) * Math.sin(Math.PI) + 2440
        value.positionY = (value.positionX - 1634) * Math.sin(Math.PI) + (value.positionY - 1634) * Math.cos(Math.PI) + 1634
      }

      if (this.activeRobot && value.mapId !== this.mapId) {
        // mapId变化 刷新地图以及数据
        this.robotIdArr.forEach(item => {
          // 更新对应机器人的mapId
          if (item.robotId == data.deviceId) {
            item.mapId = value.mapId
          }
        })
        this.floorList.forEach((f, index) => {
          // 修改对应楼层的标识
          if (f.mapId == value.mapId) {
            this.floorChoose = index
          }
        })
        this.mapId = value.mapId
        this.drawArea.clear()
        // 当前机器人位置取消
        this.mqtt.subArr.forEach(item => {
          if (item.indexOf('position') > -1) {
            this.mqtt.unsub({ topic: item })
          }
        })
        // 清除数据
        this.drawShape = {
          robot: {},
          line: {}
        }
        this.historyLine = {}
        this.mqtt.messageArr = []
        // 清空颜色
        // this.resetColor()
        const arr = []
        const promiseArr = []
        this.robotIdArr.forEach(e => {
          //筛选选中楼层地图上的机器人
          if (e.mapId === this.mapId) {
            arr.push(e.robotId)
            setTimeout(() => {
              this.subRobotPosi(true, e.robotId) // 重新订阅消息
            }, 50)

            if (e.connectionStatus) {
              //在线机器人
              promiseArr.push(
                (async e => {
                  await this.getHistoryLine(e)
                })(e)
              )
            }
          }
        })
        this.historyArr = promiseArr
        const alreadyImg = () => {
          Promise.all(this.historyArr)
            .then(res => {
              console.log('已获取所有在线机器人路径')
              this.handleHistory()
            })
            .catch(e => {
              this.$message({
                message: '获取历史路径错误',
                type: 'error'
              })
              this.handleHistory()
            })
        }
        this.robotIds = arr
        this.getBottomImg(alreadyImg)
        return
      }
      if (!this.drawShape.robot[data.deviceId]) {
        this.drawShape.robot[data.deviceId] = {}
        this.drawShape.line[data.deviceId] = {}
        this.robotIdArr.forEach(i => {
          if (i.robotId === data.deviceId) {
            this.drawShape.line[data.deviceId].color = i.color
            this.drawShape.robot[data.deviceId].color = i.color
            this.drawShape.robot[data.deviceId].name = i.robotName
          }
        })
        this.drawShape.robot[data.deviceId].arr = []

        this.drawShape.line[data.deviceId].arr = []
      } // 永远以当前现在获取的点作为机器人原点
      if (this.drawShape.robot[data.deviceId].arr.length) {
        this.drawShape.line[data.deviceId].arr.push({
          positionX: this.drawShape.robot[data.deviceId].arr[0].value.positionX,
          positionY: this.drawShape.robot[data.deviceId].arr[0].value.positionY
        })
        this.drawShape.robot[data.deviceId].arr = [
          {
            type: 'robot',
            value
          }
        ]
      } else {
        this.drawShape.robot[data.deviceId].arr.push({
          type: 'robot',
          value: data.data
        })
      }
      this.drawShape.robot[data.deviceId].beforeX = value.positionX
      this.drawShape.robot[data.deviceId].beforeY = value.positionY
      this.robotIdArr.forEach(item => {
        item.connectionStatus = item.robotId == data.deviceId ? 1 : item.connectionStatus
      })
      if (!this.startFresh) {
        this.startFresh = true
        this.fresh = setInterval(() => {
          this.refreshLineData()
        }, 300000)
      }
      if (this.stopRender.scale || this.stopRender.move) {
        return
      }
      this.drawRobot()
    },
    handleLift(mes) {
      const data = mes.data
      if (!this.activeRobot || !data.deviceId || this.activeRobot !== data.deviceId) {
        // 添加呼梯机器人 mark
        this.animate = false
        return
      }
      if (data.elevatorStatus) {
        this.animate = true
        this.liftImg = this.lift[data.doorStatus]
        this.active = data.elevatorStatus > 1 ? 'down' : 'up'
      } else {
        this.animate = false
        this.liftImg = ''
        this.active = ''
      }
      this.floor = data.floor
    },
    // 处理机器人上报的状态信息
    handleDeviceStatus(data) {
      console.log(data)
      // const status = data.data.connectionStatus == 100 ? 0 : 1 // 现在的状态
      if (this.outlineMapRobot[data.deviceId]) {
        //离线变成在线
        this.drawArea.remove(this.outlineMapRobot[data.deviceId])
        delete this.outlineMapRobot[data.deviceId]
      }
      this.robotIdArr.forEach(e => {
        if (data.deviceId === e.robotId) {
          // if (e.connectionStatus !== status) { //在线的机器人变成离线
          //   if (status) { // 离 => 在
          //     if (this.outlineMapRobot[data.deviceId]) { //离线变成在线
          //       this.drawArea.remove(this.outlineMapRobot[data.deviceId])
          //       delete this.outlineMapRobot[data.deviceId]
          //     }
          //   } else {
          //     this.outlineMapRobot[data.deviceId] = ''
          //     this.activeRobot = (this.activeRobot && data.deviceId == this.activeRobot) ? '' : this.activeRobot // 焦点机器人离线清空
          //     this.toolObj.toolChooseFocus = (this.activeRobot && data.deviceId == this.activeRobot) ? -1 : this.toolObj.toolChooseFocus

          //     if (this.drawShape.line[data.deviceId]) {
          //       this.drawArea.remove(this.drawShape.line[data.deviceId].el)
          //       delete this.drawShape.line[data.deviceId]
          //     }
          //     if (this.historyLine[data.deviceId]) {
          //       for (const l in this.historyLine[data.deviceId]) {
          //         if (this.historyLine[data.deviceId][l].length && this.historyLine[data.deviceId][l].length > 1) {
          //           this.drawArea.remove(this.historyLine[data.deviceId][l + 'el'])
          //         }
          //       }
          //       delete this.historyLine[data.deviceId]
          //     }
          //     if (this.drawShape.robot[data.deviceId]) {
          //     // this.drawArea.remove(this.drawShape.robot[o].el)
          //       this.drawArea.remove(this.drawShape.robot[data.deviceId].circle)
          //       this.drawShape.robot[data.deviceId].el.set('opacity', 0.2)
          //       this.outlineMapRobot[data.deviceId] = this.drawShape.robot[data.deviceId].el
          //       delete this.drawShape.robot[data.deviceId]
          //     }
          //     this.drawArea.renderAll()
          //   }
          // }
          e.batteryRemain = data.data.batteryRemain
          e.cleanWater = data.data.cleanWater / 1000 === 0 ? '已空' : '正常'
          e.dirtyWater = data.data.dirtyWater / 1000 === 100 ? '已满' : '正常'
          e.taskProcess = data.data.taskProcess / 10
          e.alarmLevel = data.data.alarmLevel

          // e.connectionStatus = data.data.connectionStatus
          e.connectionStatus = 1
        }
      })

      this.robotIdArr.sort((a, b) => {
        // 在线的机器人排前面，离线的排后面
        return b.connectionStatus - a.connectionStatus
      })
    },
    drawRobot() {
      // 画的时候分两块画
      for (const r in this.drawShape.robot) {
        this.drawShape.robot[r].arr.length &&
          this.drawShape.robot[r].arr.forEach((item, index) => {
            const img = this.activeRobot == r ? this.starImg : this.robotImg
            let angle = getDegree(Number(item.value.orientationX), Number(item.value.orientationY), Number(item.value.orientationZ), Number(item.value.orientationW))
            // 默认角度为向下
            if (this.mapId == 'panpuwan') {
              // 单独适配泮浦湾
              angle += 180
            }
            const drawIcon = new fabric.Image(img, {
              scaleX: 0.6,
              scaleY: 0.6,
              originX: 'center',
              originY: 'center',
              angle: angle - 90,
              // angle: angle + 360 + 270, // 机器人默认多加了90度
              lockScalingX: true,
              lockScalingY: true,
              lockMovementY: true,
              lockMovementX: true,
              lockRotation: true,
              left: this.scalePercent.left + item.value.positionX * this.scalePercent.x * (1 + this.scalePercent.now) + img.width * 0.6 * 0.125,
              top: this.scalePercent.top + item.value.positionY * this.scalePercent.y * (1 + this.scalePercent.now) + img.height * 0.6 * 0.125,
              hoverCursor: 'default',
              selectable: false,
              opacity: this.activeRobot && this.activeRobot !== r && this.showActiveRobot ? 0 : 1
            })
            const circle = new fabric.Circle({
              radius: 25,
              fill: this.drawShape.robot[r].color,
              stroke: '',
              strokeWidth: 2,
              originX: 'center',
              originY: 'center',
              lockScalingX: true,
              lockScalingY: true,
              lockMovementY: true,
              lockMovementX: true,
              lockRotation: true,
              left: this.scalePercent.left + item.value.positionX * this.scalePercent.x * (1 + this.scalePercent.now) + img.width * 0.6 * 0.125,
              top: this.scalePercent.top + item.value.positionY * this.scalePercent.y * (1 + this.scalePercent.now) + img.height * 0.6 * 0.125,
              hoverCursor: 'default',
              selectable: false,
              evented: false,
              opacity: this.activeRobot && this.activeRobot !== r && this.showActiveRobot ? 0 : 0.45
            })
            drawIcon.on('mousedown', e => {
              if (this.canvasActiveRobot.press) {
                return
              }
              if (this.canvasActiveRobot.showMessage) {
                return
              }

              if (Object.keys(this.outlineMapRobot).length) {
                for (const o in this.outlineMapRobot) {
                  if (this.outlineMapRobot[o] == e.target) {
                    //
                    return
                  }
                }
              }
              this.canvasActiveRobot.press = true
              this.canvasActiveRobot.activeLength += 1
              // 找到当前激活的机器人
              for (const key in this.drawShape.robot) {
                if (e.target == this.drawShape.robot[key].el) {
                  this.canvasActiveRobot.id = key
                  this.canvasActiveRobot.name = this.drawShape.robot[key].name
                  // console.log(e.target)
                  this.canvasActiveRobot.top = e.target.top - 50 + 'px'
                  this.canvasActiveRobot.left = e.target.left + 'px'
                  // console.log(this.canvasActiveRobot.top, this.canvasActiveRobot.left, e.target)
                }
              }
              this.robotIdArr.forEach(e => {
                if (this.canvasActiveRobot.id == e.robotId) {
                  this.canvasActiveRobot.alarmLevel = e.alarmLevel
                }
              })

              this.canvasActiveRobot.showFun = setTimeout(() => {
                if (this.canvasActiveRobot.activeLength > 1) {
                  this.$message({
                    message: '多个机器人重叠暂不能显示机器人信息',
                    type: 'warning'
                  })
                  this.canvasActiveRobot.activeLength = 0
                  this.canvasActiveRobot.press = false
                } else {
                  this.canvasActiveRobot.showMessage = true
                  setTimeout(() => {
                    this.canvasActiveRobot.showMessage = false
                    this.canvasActiveRobot.activeLength = 0
                    this.canvasActiveRobot.press = false
                  }, 1500)
                }
              }, 200)
            })
            this.drawShape.robot[r].el && this.drawArea.remove(this.drawShape.robot[r].el)
            this.drawShape.robot[r].circle && this.drawArea.remove(this.drawShape.robot[r].circle)
            this.drawShape.robot[r].el = drawIcon
            this.drawShape.robot[r].circle = circle
            this.drawArea.add(circle)
            this.drawArea.add(drawIcon)

            this.drawArea.moveTo(circle, 8)
            this.drawArea.moveTo(drawIcon, 99)
          })
      }

      for (const key in this.drawShape.line) {
        // 画路径
        let start
        let middle
        const end = ' o'
        if (this.drawShape.line[key].arr.length > 1) {
          this.drawShape.line[key].arr.forEach((item, index) => {
            if (index === 0) {
              start =
                ' M ' +
                (this.scalePercent.x * item.positionX * (this.scalePercent.now + 1) + this.scalePercent.left) +
                ' ' +
                (this.scalePercent.y * item.positionY * (this.scalePercent.now + 1) + this.scalePercent.top)
            } else {
              middle = middle
                ? middle +
                  ' L ' +
                  (this.scalePercent.x * item.positionX * (this.scalePercent.now + 1) + this.scalePercent.left) +
                  ' ' +
                  (this.scalePercent.y * item.positionY * (this.scalePercent.now + 1) + this.scalePercent.top)
                : ' L ' +
                  (this.scalePercent.x * item.positionX * (this.scalePercent.now + 1) + this.scalePercent.left) +
                  ' ' +
                  (this.scalePercent.y * item.positionY * (this.scalePercent.now + 1) + this.scalePercent.top)
            }
          })
          const path = start + middle + end
          // console.log(path)
          this.drawShape.line[key].el && this.drawArea.remove(this.drawShape.line[key].el)
          const drawPath = new fabric.Path(path, {
            stroke: this.drawShape.line[key].color, // 需要使用动态颜色进行匹配
            fill: 'transparent',
            strokeWidth: 2,
            hoverCursor: 'default',
            evented: false,
            selectable: false,
            opacity: this.showLine ? (this.activeRobot && this.showActiveRobot && this.activeRobot !== key ? 0 : 1) : 0
          })
          // console.log(drawPath)
          this.drawShape.line[key].el = drawPath
          this.drawArea.add(drawPath)
          this.drawArea.moveTo(drawPath, 1)
        }
      }
    },
    drawMap(obj = {}) {
      if (!this.mapOrigin.width || !this.mapOrigin.height) {
        console.log('暂未获取到原图尺寸')
        return
      }
      // console.log(this.scalePercent.left, this.scalePercent.top, '偏离量')
      this.drawArea.setBackgroundImage(this.bottomMap, this.drawArea.renderAll.bind(this.drawArea), {
        scaleX: obj.x || this.drawArea.width / this.mapOrigin.width,
        scaleY: obj.y || this.drawArea.height / this.mapOrigin.height,
        left: this.scalePercent.left,
        top: this.scalePercent.top
      })
    },
    mouseUp(e) {
      this.pressing = false
      this.pressOrigin.x = ''
      this.pressOrigin.y = ''
      this.finger.x = ''
      this.finger.y = ''
    },
    mouseDown(e, finger = '') {
      // ((this.scalePercent.y * e.pointer.y* (this.scalePercent.now + 1)) + this.scalePercent.top)
      if (this.showToolBox) {
        this.showToolBox = false
      }
      // console.log(e)
      this.pressing = true
      const { x, y } = e.pointer || e.start
      const changeX = ((Math.abs(this.scalePercent.left) + x) / this.scalePercent.x) * this.resolutionX
      const changeY = (this.mapOrigin.height - (Math.abs(this.scalePercent.left) + y) / this.scalePercent.y) * this.resolutionY
      console.log(changeX, changeY)
      this.pressOrigin.x = x
      this.pressOrigin.y = y
      if (finger) {
        this.finger.x = finger.clientX
        this.finger.y = finger.clientY
      }
    },
    mouseMove(move, finger = '') {
      if (!this.pressing) {
        // 如果不是按着拖动，不移动背景图
        return
      }
      const canvasWidth = Number(this.canvasW.split('px')[0])
      const canvasHeight = Number(this.canvasH.split('px')[0])
      let x, y
      if (finger) {
        x = finger.clientX - this.finger.x + this.pressOrigin.x
        y = finger.clientY - this.finger.y + this.pressOrigin.y
        this.finger.x = finger.clientX
        this.finger.y = finger.clientY
      } else {
        x = move.pointer.x
        y = move.pointer.y
      }
      const moveX = x - this.pressOrigin.x
      const moveY = y - this.pressOrigin.y

      // 边界处理
      if (this.scalePercent.left + moveX > 0) {
        return
      }

      if (Math.abs(this.scalePercent.left + moveX) > Math.abs(this.scalePercent.x) * (1 + this.scalePercent.now) * this.mapOrigin.width - canvasWidth) {
        return
      }
      if (this.scalePercent.top + moveY > 0) {
        return
      }

      if (Math.abs(this.scalePercent.top + moveY) > Math.abs(this.scalePercent.y) * (1 + this.scalePercent.now) * this.mapOrigin.height - canvasHeight) {
        return
      }

      this.scalePercent.before = this.scalePercent.now
      this.scalePercent.left += moveX
      this.scalePercent.top += moveY

      this.handleMove(moveX, moveY, this)
      this.pressOrigin.x = x
      this.pressOrigin.y = y
    },
    handleMove: throttle((moveX, moveY, _this) => {
      _this.stopRender.move = true
      _this.handleModuleChange('move', { moveX, moveY })
      _this.workScaleMove()
      _this.handleHistory()
      _this.drawMap({
        x: _this.scalePercent.x * (1 + _this.scalePercent.now),
        y: _this.scalePercent.y * (1 + _this.scalePercent.now),
        move: { moveX, moveY }
      })

      _this.stopRender.move = false
    }, 40),
    scale(num, isButton = false) {
      const canvasWidth = Number(this.canvasW.split('px')[0])
      const canvasHeight = Number(this.canvasH.split('px')[0])
      let handleX, handleY
      if (num > 0) {
        // 放大
        if (this.scalePercent.x * (1 + this.scalePercent.now) > 1) {
          this.$message({
            type: 'warnging',
            message: '不能再放大了'
          })
          return
        }
        this.scalePercent.now += 1
        this.scalePercent.before = this.scalePercent.now
      } else {
        // 缩小
        if (this.scalePercent.now - 1 < 0) {
          this.$message({
            type: 'warnging',
            message: '不能再缩小了'
          })
          return
        }
        this.scalePercent.before = this.scalePercent.now
        this.scalePercent.now -= 1
      }
      if (this.mousePosi.x || this.mousePosi.y) { // 带有鼠标缩放则走相对位置逻辑 找出当前点相对地图的位置
        const changeX = Math.abs(this.scalePercent.left) + this.mousePosi.x
        const changeY = Math.abs(this.scalePercent.top) + this.mousePosi.y
        this.scalePercent.left = num > 0 ? -changeX : this.scalePercent.left + this.mousePosi.x
        this.scalePercent.top = num > 0 ? -changeY : this.scalePercent.top + this.mousePosi.y
        if (this.scalePercent.left > 0) {
          this.scalePercent.left = 0
        }
        if (this.scalePercent.top > 0) {
          this.scalePercent.top = 0
        }
        if (Math.abs(this.scalePercent.left) > ((Math.abs(this.scalePercent.x) * (1 + this.scalePercent.now) * this.mapOrigin.width) - canvasWidth)) {
          this.scalePercent.left = canvasWidth - (Math.abs(this.scalePercent.x) * (1 + this.scalePercent.now) * this.mapOrigin.width)
        }
        if (Math.abs(this.scalePercent.top) > ((Math.abs(this.scalePercent.y) * (1 + this.scalePercent.now) * this.mapOrigin.height) - canvasHeight)) {
          this.scalePercent.top = canvasHeight - (Math.abs(this.scalePercent.y) * (1 + this.scalePercent.now) * this.mapOrigin.height)
        }
      } else {
        if (isButton) { // 使用button缩放
          const center = this.drawArea.getCenter()
          const changeX = Math.abs(this.scalePercent.left) + center.left
          const changeY = Math.abs(this.scalePercent.top) + center.top
          this.scalePercent.left = num > 0 ? -changeX : this.scalePercent.left + center.left
          this.scalePercent.top = num > 0 ? -changeY : this.scalePercent.top + center.top
          if (this.scalePercent.left > 0) {
            this.scalePercent.left = 0
          }
          if (this.scalePercent.top > 0) {
            this.scalePercent.top = 0
          }
          if (Math.abs(this.scalePercent.left) > ((Math.abs(this.scalePercent.x) * (1 + this.scalePercent.now) * this.mapOrigin.width) - canvasWidth)) {
            this.scalePercent.left = canvasWidth - (Math.abs(this.scalePercent.x) * (1 + this.scalePercent.now) * this.mapOrigin.width)
          }
          if (Math.abs(this.scalePercent.top) > ((Math.abs(this.scalePercent.y) * (1 + this.scalePercent.now) * this.mapOrigin.height) - canvasHeight)) {
            this.scalePercent.top = canvasHeight - (Math.abs(this.scalePercent.y) * (1 + this.scalePercent.now) * this.mapOrigin.height)
          }
        } else {
          if (this.scalePercent.left || this.scalePercent.top) { // 如果有移动过则要按移动重新操作位置
            this.scalePercent.left = (this.scalePercent.left * this.scalePercent.now) / this.scalePercent.before
            this.scalePercent.top = (this.scalePercent.top * this.scalePercent.now) / this.scalePercent.before
            this.scalePercent.before = this.scalePercent.now
          }
        }
      }
      if (this.scalePercent.now === 0) {
        // 还原此时原点
        this.scalePercent.left = 0
        this.scalePercent.top = 0
      }
      this.handleScale(this)
    },
    handleScale: throttle(_this => {
      _this.stopRender.scale = true
      _this.workScaleMove()
      _this.handleModuleChange('scale')
      _this.handleHistory()
      _this.drawMap({
        // left: this.scalePercent.left,
        // top: this.scalePercent.top,
        x: _this.scalePercent.x * (1 + _this.scalePercent.now), // 换算百分比
        y: _this.scalePercent.y * (1 + _this.scalePercent.now) // 换算百分比
      })
      _this.stopRender.scale = false
    }, 50),
    handleModuleChange(type) {
      // icon只有坐标变化 特殊原点以及宽高也需要变化
      if (type === 'scale') {
        for (const key in this.drawShape.robot) {
          this.drawShape.robot[key].arr.forEach(item => {
            let angle = getDegree(Number(item.value.orientationX), Number(item.value.orientationY), Number(item.value.orientationZ), Number(item.value.orientationW))
            if (this.mapId == 'panpuwan') {
              // 单独适配泮浦湾
              angle += 180
            }
            const scaleX = this.scalePercent.x * item.value.positionX * (this.scalePercent.now + 1) + this.scalePercent.left
            const scaleY = this.scalePercent.y * item.value.positionY * (this.scalePercent.now + 1) + this.scalePercent.top
            const img = this.activeRobot == key ? this.starImg : this.robotImg
            const imgInstance = new fabric.Image(img, {
              left: scaleX + img.width * 0.6 * 0.125,
              top: scaleY + img.height * 0.6 * 0.125,
              scaleX: 0.6,
              scaleY: 0.6,
              originX: 'center',
              originY: 'center',
              angle: angle - 90, // fabric 只接受正数坐标
              lockScalingX: true,
              lockScalingY: true,
              lockMovementY: true,
              lockMovementX: true,
              lockRotation: true,
              hoverCursor: 'default',
              selectable: false,
              opacity: this.activeRobot !== key && this.showActiveRobot ? 0 : 1
            })

            const circle = new fabric.Circle({
              radius: 25,
              fill: this.drawShape.robot[key].color,
              stroke: '',
              strokeWidth: 2,
              originX: 'center',
              originY: 'center',
              lockScalingX: true,
              lockScalingY: true,
              lockMovementY: true,
              lockMovementX: true,
              lockRotation: true,
              left: this.scalePercent.left + item.value.positionX * this.scalePercent.x * (1 + this.scalePercent.now) + img.width * 0.6 * 0.125,
              top: this.scalePercent.top + item.value.positionY * this.scalePercent.y * (1 + this.scalePercent.now) + img.height * 0.6 * 0.125,
              hoverCursor: 'default',
              selectable: false,
              evented: false,
              opacity: this.activeRobot && this.activeRobot !== key && this.showActiveRobot ? 0 : 0.45
            })
            imgInstance.on('mousedown', e => {
              if (this.canvasActiveRobot.press) {
                return
              }
              if (this.canvasActiveRobot.showMessage) {
                return
              }

              if (Object.keys(this.outlineMapRobot).length) {
                for (const o in this.outlineMapRobot) {
                  if (this.outlineMapRobot[o] == e.target) {
                    //
                    return
                  }
                }
              }
              // console.log(this.canvasActiveRobot.top, this.canvasActiveRobot.left, e.target)
              this.canvasActiveRobot.press = true
              this.canvasActiveRobot.activeLength += 1
              //找到当前激活的机器人
              for (const key in this.drawShape.robot) {
                if (e.target == this.drawShape.robot[key].el) {
                  this.canvasActiveRobot.id = key
                  this.canvasActiveRobot.name = this.drawShape.robot[key].name
                  this.canvasActiveRobot.top = this.drawShape.robot[key].el.top - 50 + 'px'
                  this.canvasActiveRobot.left = this.drawShape.robot[key].el.left + 'px'
                  // console.log(this.canvasActiveRobot.top, this.canvasActiveRobot.left, e.target)
                }
              }
              this.robotIdArr.forEach(e => {
                if (this.canvasActiveRobot.id == e.robotId) {
                  this.canvasActiveRobot.alarmLevel = e.alarmLevel
                }
              })
              this.canvasActiveRobot.showFun = setTimeout(() => {
                if (this.canvasActiveRobot.activeLength > 1) {
                  this.$message({
                    message: '多个机器人重叠暂不能显示机器人信息',
                    type: 'warning'
                  })
                  this.canvasActiveRobot.activeLength = 0
                } else {
                  this.canvasActiveRobot.showMessage = true
                  setTimeout(() => {
                    this.canvasActiveRobot.showMessage = false
                    this.canvasActiveRobot.activeLength = 0
                  }, 1500)
                }
              }, 200)
            })
            this.drawShape.robot[key].el && this.drawArea.remove(this.drawShape.robot[key].el)
            this.drawShape.robot[key].circle && this.drawArea.remove(this.drawShape.robot[key].circle)
            this.drawArea.add(imgInstance)
            this.drawArea.add(circle)
            this.drawShape.robot[key].percent = this.scalePercent.now + 1
            this.drawShape.robot[key].el = imgInstance
            this.drawShape.robot[key].circle = circle
            this.drawArea.moveTo(circle, 8)
            this.drawArea.moveTo(imgInstance, 99)
          })
        }
      }
      if (type === 'move') {
        // const { moveX, moveY } = before
        for (const key in this.drawShape.robot) {
          this.drawShape.robot[key].arr.forEach(item => {
            let angle = getDegree(Number(item.value.orientationX), Number(item.value.orientationY), Number(item.value.orientationZ), Number(item.value.orientationW))
            const beforeX = this.scalePercent.x * item.value.positionX * (this.scalePercent.now + 1) + this.scalePercent.left
            const beforeY = this.scalePercent.y * item.value.positionY * (this.scalePercent.now + 1) + this.scalePercent.top
            if (this.mapId == 'panpuwan') {
              // 单独适配泮浦湾
              angle += 180
            }
            const img = this.activeRobot == key ? this.starImg : this.robotImg
            const imgInstance = new fabric.Image(img, {
              left: beforeX + +(img.width * 0.6 * 0.125),
              top: beforeY + +(img.height * 0.6 * 0.125),
              originX: 'center',
              originY: 'center',
              scaleX: 0.6,
              scaleY: 0.6,
              angle: angle - 90, // fabric 只接受正数坐标
              lockScalingX: true,
              lockScalingY: true,
              lockMovementY: true,
              lockMovementX: true,
              lockRotation: true,
              hoverCursor: 'default',

              selectable: false,
              opacity: this.activeRobot && this.activeRobot !== key && this.showActiveRobot ? 0 : 1
            })

            const circle = new fabric.Circle({
              radius: 25,
              fill: this.drawShape.robot[key].color,
              stroke: '',
              strokeWidth: 2,
              originX: 'center',
              originY: 'center',
              lockScalingX: true,
              lockScalingY: true,
              lockMovementY: true,
              lockMovementX: true,
              lockRotation: true,
              left: this.scalePercent.left + item.value.positionX * this.scalePercent.x * (1 + this.scalePercent.now) + img.width * 0.6 * 0.125,
              top: this.scalePercent.top + item.value.positionY * this.scalePercent.y * (1 + this.scalePercent.now) + img.height * 0.6 * 0.125,
              hoverCursor: 'default',
              selectable: false,
              evented: false,
              opacity: this.activeRobot && this.activeRobot !== key && this.showActiveRobot ? 0 : 0.45
            })
            imgInstance.on('mousedown', e => {
              if (this.canvasActiveRobot.press) {
                return
              }
              if (this.canvasActiveRobot.showMessage) {
                return
              }
              if (Object.keys(this.outlineMapRobot).length) {
                for (const o in this.outlineMapRobot) {
                  if (this.outlineMapRobot[o] == e.target) {
                    //
                    return
                  }
                }
              }
              this.canvasActiveRobot.press = true
              this.canvasActiveRobot.activeLength += 1
              //找到当前激活的机器人
              for (const key in this.drawShape.robot) {
                if (e.target == this.drawShape.robot[key].el) {
                  this.canvasActiveRobot.id = key
                  this.canvasActiveRobot.name = this.drawShape.robot[key].name
                  this.canvasActiveRobot.top = this.drawShape.robot[key].el.top - 50 + 'px'
                  this.canvasActiveRobot.left = this.drawShape.robot[key].el.left + 'px'
                  // console.log(this.canvasActiveRobot.top, this.canvasActiveRobot.left, e.target)
                }
              }
              this.robotIdArr.forEach(e => {
                if (this.canvasActiveRobot.id == e.robotId) {
                  this.canvasActiveRobot.alarmLevel = e.alarmLevel
                }
              })
              this.canvasActiveRobot.showFun = setTimeout(() => {
                if (this.canvasActiveRobot.activeLength > 1) {
                  this.$message({
                    message: '多个机器人重叠暂不能显示机器人信息',
                    type: 'warning'
                  })
                } else {
                  this.canvasActiveRobot.showMessage = true
                  setTimeout(() => {
                    this.canvasActiveRobot.showMessage = false
                    this.canvasActiveRobot.activeLength = 0
                  }, 1500)
                }
              }, 200)
            })
            this.drawShape.robot[key].el && this.drawArea.remove(this.drawShape.robot[key].el)
            this.drawShape.robot[key].circle && this.drawArea.remove(this.drawShape.robot[key].circle)
            this.drawArea.add(circle)
            this.drawArea.add(imgInstance)
            this.drawArea.moveTo(circle, 8)
            this.drawArea.moveTo(imgInstance, 99)
            this.drawShape.robot[key].circle = circle
            this.drawShape.robot[key].el = imgInstance
          })
        }
      }
    },
    // 获取组织列表（楼层）
    async getFloor() {
      const res = await getfloorMap('16044558013643816') //.then(res => {
      // console.log(res)
      // if (res.resultCode === 0) {
      if (!res.data || !res.data.length) {
        this.$message({
          message: '没有获取到楼层',
          type: 'error'
        })
        return
      }
      const arr = []
      res.data.forEach((e, index) => {
        if (e.maps.length && e.maps[0].mapId) {
          this.saveMap[e.maps[0].mapId] = ''
        }
        if (e.floor == 10) {
          this.hasTen = true
          this.floorChoose = index
          this.mapId = e.maps.length && e.maps[0].mapId
        }
        const obj = {}
        obj.storey = e.floor
        obj.floor = /^[\u3220-\uFA29]+$/.test(e.floor) ? e.floor : e.floor + '层'
        obj.floorId = e.floorId
        obj.mapId = e.maps.length > 0 ? e.maps[0].mapId : ''
        arr.push(obj)
      })
      this.floorList = arr
      // }
      // })
    },
    // 获取楼栋的机器人列表
    async getrobotList() {
      const res = await mapAndRobot(JSON.stringify({ organizationId: '16044558013591350' }))
      if (res.resultCode === 0) {
        if (!res.data.robotIdMapIds || !res.data.robotIdMapIds.length) {
          this.$message({
            message: '没有获取到机器人列表',
            type: 'error'
          })
          return
        }
        this.robotIdArr = res.data.robotIdMapIds
        // 默认显示有地图有机器人的楼层
        this.floorList.forEach((e, idx) => {
          if (!this.hasTen) {
            this.robotIdArr.forEach(ele => {
              if (e.mapId === ele.mapId) {
                this.floorChoose = idx
                this.mapId = e.mapId
              }
            })
          }
        })
        //筛选选中楼层地图上的机器人
        const arr = []
        const promiseArr = []
        this.robotIdArr.forEach(e => {
          e.color = this.getColor()
          if (e.mapId === this.mapId) {
            arr.push(e.robotId)

            if (e.connectionStatus) {
              //在线机器人
              promiseArr.push(
                (async e => {
                  await this.getHistoryLine(e)
                })(e)
              )
            }
          }
        })
        // await Promise.all(promiseArr).then(res => {
        // console.log('已获取所有在线机器人路径')
        // })
        this.robotIds = arr
        console.log(this.mapId, this.robotIds)
        this.historyArr = promiseArr
      }
    },
    // 获取地图分辨率
    getresolution(x, y) {
      getMessage(this.mapId).then(res => {
        console.log(res)
        if (res.resultCode === 0 && res.data) {
          if (res.data.attribute.resolutionX !== 0) {
            this.resolutionX = (res.data.attribute && res.data.attribute.resolutionX) || this.resolutionX
          }

          if (res.data.attribute.resolutionY !== 0) {
            this.resolutionY = (res.data.attribute && res.data.attribute.resolutionY) || this.resolutionY
          }
          console.log(res.data.attribute.resolutionX, res.data.attribute.resolutionY)
        }
      })
    },
    // 获取地图底图
    async getBottomImg(fun = '') {
      if (!this.saveMap[this.mapId]) {
        const img = await this.$https('getMapImg', {
          RESTful: this.mapId + '?fileType=0'
        })
        // await bottomImg(this.mapId).then(img => {
        this.bottomMap = img && 'data:image/jpeg;base64,' + img
        this.saveMap[this.mapId] = this.bottomMap
      } else {
        this.bottomMap = this.saveMap[this.mapId]
      }
      const res = await this.$https('getDrawMap', {
        RESTful: this.mapId
      })
      if (res && Object.keys(res).length) {
        const { attribute } = res
        this.resolutionX = (attribute && attribute.resolutionX) || 0.02
        this.resolutionY = (attribute && attribute.resolutionY) || 0.02
      }
      const map = new Image()
      map.src = this.bottomMap
      map.onload = () => {
        this.mapOrigin.width = map.width
        this.mapOrigin.height = map.height
        if (this.firstIn) {
          const obj = document.getElementById('map')
          const clientH = `${document.documentElement.clientHeight}`
          const clientW = `${document.documentElement.clientWidth}`
          const maxH = clientH - 126
          const maxW = clientW - 394
          const hwpercent = this.mapOrigin.height / this.mapOrigin.width
          let currentW, currentH
          const testH = maxW * hwpercent
          if (testH <= maxH) {
            currentW = maxW
            currentH = testH
          } else {
            currentH = maxH
            currentW = maxH / hwpercent
          }
          const myCanvas = "<canvas id='canvas' width=" + currentW + 'px height=' + currentH + 'px ></canvas>'
          this.canvasH = currentH + 'px'
          this.canvasW = currentW + 'px'
          obj.insertAdjacentHTML('afterBegin', myCanvas)
          const handleMouse = throttle(event => {
            const { pointer, e } = event
            // this.mouseX = pointer.x
            // this.mouseY = pointer.y
            this.mousePosi = pointer
            this.scale(-e.deltaY)
          }, 1000)
          this.drawArea = new fabric.Canvas('canvas', { selection: null })
          this.drawArea.centeredscaling = true
          this.drawArea.on('mouse:down', this.mouseDown)
          this.drawArea.on('mouse:move', this.mouseMove)
          this.drawArea.on('mouse:up', this.mouseUp)
          this.drawArea.on('mouse:wheel', e => {
            handleMouse(e)
          })
          this.compatibleMobile()
          this.firstIn = false
        }
        this.scalePercent.x = this.drawArea.width / this.mapOrigin.width
        this.scalePercent.y = this.drawArea.height / this.mapOrigin.height
        this.drawMap({
          left: 0,
          top: 0
        })
        fun && fun()
      }
    },
    async getHistoryLine(e) {
      const { robotId, mapId } = e
      // console.log(robotId, mapId)
      const params = { parameter: { deviceId: robotId, mapId } }
      const data = await this.$https('getRobotHistroy', {
        params
      })
      if (data && data.length > 1) {
        this.historyLine[robotId] = {}
        data.forEach(item => {
          if (!this.historyLine[robotId][item.pathLabel]) {
            this.historyLine[robotId][item.pathLabel] = []
            this.historyLine[robotId][item.pathLabel + 'el'] = {}
          }
          this.historyLine[robotId][item.pathLabel].push({
            positionX: Number((item.positionX / this.resolutionX).toFixed(2)),
            positionY: Number((item.positionY / this.resolutionY).toFixed(2))
          })
        })
      }
    },
    historyChange() {
      for (const key in this.historyLine) {
        for (const l in this.historyLine[key]) {
          if (this.historyLine[key][l].length && this.historyLine[key][l].length > 1) {
            this.historyLine[key][l + 'el'].set('opacity', this.showLine ? (this.activeRobot && this.showActiveRobot && this.activeRobot !== key ? 0 : 1) : 0)
          }
        }
      }
    },
    handleHistory() {
      if (Object.keys(this.historyLine).length) {
        this.historyWorker = new LineWorker()
        this.historyWorker.onmessage = this.getLineWorker
        const data = {}
        data.historyLine = this.historyLine
        data.drawShapeRobot = this.drawShape.robot
        data.robotIdArr = this.robotIdArr
        data.mapOrigin = this.mapOrigin
        data.scalePercent = this.scalePercent
        data.showLine = this.showLine
        data.activeRobot = this.activeRobot
        data.showActiveRobot = this.showActiveRobot
        data.mapId = this.mapId
        this.historyWorker.postMessage(JSON.stringify(data))
      }

      // for (const key in this.historyLine) { // 不同的机器人路径
      //   for (const l in this.historyLine[key]) { // 机器人不同时间段路径
      //     let start; let middle; const end = ' o'; let color
      //     if (this.historyLine[key][l].length && this.historyLine[key][l].length > 1) {
      //       this.historyLine[key][l].forEach((item, index) => {
      //         const rightY = this.mapOrigin.height - item.positionY
      //         let handleX, handleY
      //         // 如果当前地图为泮浦湾,所有点位发生旋转
      //         // x0= (x - rx0)*cos(a) - (y - ry0)*sin(a) + rx0 ; 以某点进行旋转的公式 (rx0,ry0)是（2440，1634）
      //         // y0= (x - rx0)*sin(a) + (y - ry0)*cos(a) + ry0 ;
      //         if (this.mapId == 'panpuwan') { // 只有泮浦湾的点特殊处理
      //           handleX = item.positionX - 2440 * Math.cos(Math.PI) - (rightY - 1634) * Math.sin(Math.PI) + 2440
      //           handleY = item.positionX - 1634 * Math.sin(Math.PI) + (rightY - 1634) * Math.cos(Math.PI) + 1634
      //         } else {
      //           handleX = item.positionX
      //           handleY = rightY
      //         }
      //         if (index == 0) {
      //           start = ' M ' + ((this.scalePercent.x * handleX * (this.scalePercent.now + 1)) + this.scalePercent.left) + ' ' +
      //                   ((this.scalePercent.y * handleY * (this.scalePercent.now + 1)) + this.scalePercent.top)
      //         } else {
      //           middle = middle
      //             ? middle + ' L ' +
      //               ((this.scalePercent.x * handleX * (this.scalePercent.now + 1)) + this.scalePercent.left) + ' ' +
      //               ((this.scalePercent.y * handleY * (this.scalePercent.now + 1)) + this.scalePercent.top)
      //             : ' L ' +
      //               ((this.scalePercent.x * handleX * (this.scalePercent.now + 1)) + this.scalePercent.left) + ' ' +
      //               ((this.scalePercent.y * handleY * (this.scalePercent.now + 1)) + this.scalePercent.top)
      //         }
      //       })
      //       const path = start + middle + end
      //       console.log(path)
      //       if (this.drawShape.robot[key]) {
      //         color = this.drawShape.robot[key].color
      //       } else {
      //         this.robotIdArr.forEach(item => {
      //           if (item.robotId == key) {
      //             color = item.color
      //           }
      //         })
      //       }

      //       const newPath = new fabric.Path(path, {
      //         stroke: color,
      //         fill: 'transparent',
      //         strokeWidth: 2,
      //         lockScalingX: true,
      //         lockScalingY: true,
      //         lockMovementY: true,
      //         lockMovementX: true,
      //         lockRotation: true,
      //         // originX: 'center',
      //         // originY: 'center',
      //         opacity: this.showLine ? (this.activeRobot && this.showActiveRobot && this.activeRobot !== key ? 0 : 1) : 0,
      //         hoverCursor: 'default',
      //         selectable: false,
      //         evented: false
      //       })
      //       this.historyLine[key][l + 'el'] && this.drawArea.remove(this.historyLine[key][l + 'el'])
      //       this.drawArea.add(newPath)
      //       this.drawArea.moveTo(newPath, 0)
      //       this.historyLine[key][l + 'el'] = newPath
      //     }
      //   }
      // }
    },
    refreshLineData() {
      // 清空大部分画布元素
      for (const r in this.drawShape.robot) {
        this.drawShape.robot[r].el && this.drawArea.remove(this.drawShape.robot[r].el)
        this.drawShape.robot[r].circle && this.drawArea.remove(this.drawShape.robot[r].circle)
      }
      for (const l in this.drawShape.line) {
        this.drawShape.line[l].el && this.drawArea.remove(this.drawShape.line[l].el)
      }
      for (const h in this.historyLine) {
        for (const l in this.historyLine[h]) {
          if (this.historyLine[h][l].length && this.historyLine[h][l].length > 1) {
            this.drawArea.remove(this.historyLine[h][l + 'el'])
          }
        }
      }
      // 清空数据
      this.historyLine = {}
      this.drawShape = {
        robot: {},
        line: {}
      }
      this.mqtt.messageArr = []
      //楼层上的机器人
      const promiseArr = []
      this.robotIdArr.forEach(e => {
        //筛选选中楼层地图上的机器人
        if (e.mapId === this.mapId) {
          if (e.connectionStatus) {
            // 在线机器人重新获取数据
            promiseArr.push(
              (async e => {
                await this.getHistoryLine(e)
              })(e)
            )
          }
        }
      })
      Promise.all(promiseArr)
        .then(res => {
          console.log('获取完数据')
          this.handleHistory()
        })
        .catch(e => {
          this.$message({
            message: '获取历史路径错误',
            type: 'error'
          })
          this.handleHistory()
        })
    }
  }
}
</script>


